import {
  __publicField
} from "./chunk-BYYN2XO5.js";

// node_modules/kirbyuse/dist/index.mjs
var globalVue = window.Vue;
function usePanel() {
  return window.panel;
}
function useApi() {
  return usePanel().api;
}
function useApp() {
  return usePanel().app;
}
function useBlock(props, emit) {
  const field = (name, fallback = null) => {
    let field2 = null;
    for (const tab of Object.values(
      props.fieldset.tabs ?? {}
    )) {
      if (tab.fields[name]) {
        field2 = tab.fields[name];
      }
    }
    return field2 ?? fallback;
  };
  const open = () => {
    emit == null ? void 0 : emit("open");
  };
  const update = (content) => {
    emit == null ? void 0 : emit("update", {
      ...props.content,
      ...content
    });
  };
  return {
    field,
    open,
    update
  };
}
var isKirby5 = () => window.panel.plugins.viewButtons !== void 0;
var isKirby4 = () => !isKirby5();
function useStore() {
  if (isKirby5()) {
    return new Proxy({}, {
      get() {
        throw new Error(
          "Vuex store is not available. Are you using Kirby 5? Use the `useContent` composable instead."
        );
      }
    });
  }
  const store = usePanel().app.$store;
  return store;
}
function useContent() {
  const panel = usePanel();
  const store = useStore();
  const _isKirby5 = isKirby5();
  const currentContent = _isKirby5 ? computed(() => panel.view.props.content) : computed(() => store.getters["content/values"]());
  const contentChanges = _isKirby5 ? computed(() => panel.content.changes()) : computed(() => store.getters["content/changes"]());
  const hasChanges = _isKirby5 ? computed(() => Object.keys(contentChanges.value).length > 0) : computed(() => store.getters["content/hasChanges"]());
  const content = _isKirby5 ? panel.content : new Proxy({}, {
    get() {
      return () => {
      };
    }
  });
  const update = async (values, save = true) => {
    if (!_isKirby5 && values) {
      for (const [key, value] of Object.entries(values)) {
        store.dispatch("content/update", [key, value]);
      }
    }
    const viewContent = content.merge(values);
    if (save) {
      await content.save(viewContent);
    }
  };
  return {
    // Properties
    content,
    // Reactive getters
    currentContent,
    contentChanges,
    hasChanges,
    // Methods
    update
  };
}
function useDialog() {
  function openTextDialog(text) {
    let result = false;
    return new Promise((resolve) => {
      const panel = usePanel();
      panel.dialog.open({
        component: "k-text-dialog",
        props: { text },
        on: {
          // Close event will always be triggered, even on submit
          close: () => {
            setTimeout(() => {
              resolve(result);
            }, 25);
          },
          submit: () => {
            result = true;
            panel.dialog.close();
          }
        }
      });
    });
  }
  function openFieldsDialog(props) {
    let result;
    return new Promise((resolve) => {
      const panel = usePanel();
      panel.dialog.open({
        component: "k-form-dialog",
        props,
        on: {
          // Close event will always be triggered, even on submit
          close: () => {
            setTimeout(() => {
              resolve(result);
            }, 25);
          },
          submit: (event) => {
            result = event;
            panel.dialog.close();
          }
        }
      });
    });
  }
  return {
    openTextDialog,
    openFieldsDialog
  };
}
function useI18n() {
  const panel = usePanel();
  function t(value) {
    if (!value || typeof value === "string") return value;
    return value[panel.translation.code] ?? Object.values(value)[0];
  }
  return {
    t
  };
}
function useSection() {
  const api = useApi();
  const load = ({ parent, name }) => api.get(`${parent}/sections/${name}`);
  return {
    load
  };
}
var LOG_LEVELS = {
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3
};
function createLogger(tag) {
  const reporter = new BrowserReporter();
  return new Proxy({}, {
    get(target, prop) {
      return (...args) => {
        reporter.log({
          level: LOG_LEVELS[prop],
          type: prop,
          tag,
          args
        });
      };
    }
  });
}
var BrowserReporter = class {
  constructor() {
    __publicField(this, "defaultColor", "#7f8c8d");
    // Gray
    __publicField(this, "levelColorMap", {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    });
    __publicField(this, "typeColorMap", {
      success: "#2ecc71"
      // Green
    });
  }
  log(logEvent) {
    const consoleLogFn = resolveLogFn(logEvent.level);
    const type = logEvent.type === "log" ? "" : logEvent.type;
    const tag = logEvent.tag || "";
    const color = this.typeColorMap[logEvent.type] || this.levelColorMap[logEvent.level] || this.defaultColor;
    const style = `
background: ${color};
border-radius: 0.5em;
color: white;
font-weight: bold;
padding: 2px 0.5em;
`.trimStart();
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logEvent.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logEvent.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logEvent.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logEvent.args);
    }
  }
};
function resolveLogFn(level) {
  if (level < 1) return console.error;
  return console.log;
}
var registeredAssets = [];
var moduleCache = /* @__PURE__ */ new Map();
async function registerPluginAssets(assets) {
  if (!Array.isArray(assets)) {
    throw new TypeError(`Expected an array, got ${typeof assets}`);
  }
  for (const asset of assets) {
    if (!registeredAssets.some((existing) => existing.filename === asset.filename)) {
      registeredAssets.push(asset);
    }
  }
}
function resolvePluginAsset(filename) {
  if (registeredAssets.length === 0) {
    throw new Error("Plugin assets not registered");
  }
  const asset = registeredAssets.find((asset2) => asset2.filename === filename);
  if (!asset) {
    throw new Error(`Plugin asset "${filename}" not found`);
  }
  return asset;
}
async function loadPluginModule(filename) {
  if (!filename.endsWith(".js")) {
    filename += ".js";
  }
  if (moduleCache.has(filename)) {
    return moduleCache.get(filename);
  }
  const asset = resolvePluginAsset(filename);
  const mod = await import(
    /* @vite-ignore */
    asset.url
  );
  moduleCache.set(filename, mod);
  return mod;
}
var computed = globalVue.computed;
var customRef = globalVue.customRef;
var defineAsyncComponent = globalVue.defineAsyncComponent;
var defineComponent = globalVue.defineComponent;
var effectScope = globalVue.effectScope;
var getCurrentInstance = globalVue.getCurrentInstance;
var getCurrentScope = globalVue.getCurrentScope;
var h = globalVue.h;
var inject = globalVue.inject;
var isProxy = globalVue.isProxy;
var isReactive = globalVue.isReactive;
var isReadonly = globalVue.isReadonly;
var isRef = globalVue.isRef;
var isShallow = globalVue.isShallow;
var markRaw = globalVue.markRaw;
var nextTick = globalVue.nextTick;
var onActivated = globalVue.onActivated;
var onBeforeMount = globalVue.onBeforeMount;
var onBeforeUnmount = globalVue.onBeforeUnmount;
var onBeforeUpdate = globalVue.onBeforeUpdate;
var onDeactivated = globalVue.onDeactivated;
var onErrorCaptured = globalVue.onErrorCaptured;
var onMounted = globalVue.onMounted;
var onRenderTracked = globalVue.onRenderTracked;
var onRenderTriggered = globalVue.onRenderTriggered;
var onScopeDispose = globalVue.onScopeDispose;
var onServerPrefetch = globalVue.onServerPrefetch;
var onUnmounted = globalVue.onUnmounted;
var onUpdated = globalVue.onUpdated;
var provide = globalVue.provide;
var proxyRefs = globalVue.proxyRefs;
var reactive = globalVue.reactive;
var readonly = globalVue.readonly;
var ref = globalVue.ref;
var shallowReactive = globalVue.shallowReactive;
var shallowReadonly = globalVue.shallowReadonly;
var shallowRef = globalVue.shallowRef;
var toRaw = globalVue.toRaw;
var toRef = globalVue.toRef;
var toRefs = globalVue.toRefs;
var triggerRef = globalVue.triggerRef;
var unref = globalVue.unref;
var useAttrs = globalVue.useAttrs;
var useCssModule = globalVue.useCssModule;
var useCssVars = globalVue.useCssVars;
var useListeners = globalVue.useListeners;
var useSlots = globalVue.useSlots;
var watch = globalVue.watch;
var watchEffect = globalVue.watchEffect;
var watchPostEffect = globalVue.watchPostEffect;
var watchSyncEffect = globalVue.watchSyncEffect;
export {
  computed,
  createLogger,
  customRef,
  defineAsyncComponent,
  defineComponent,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  globalVue,
  h,
  inject,
  isKirby4,
  isKirby5,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow,
  loadPluginModule,
  markRaw,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  provide,
  proxyRefs,
  reactive,
  readonly,
  ref,
  registerPluginAssets,
  resolvePluginAsset,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  useApi,
  useApp,
  useAttrs,
  useBlock,
  useContent,
  useCssModule,
  useCssVars,
  useDialog,
  useI18n,
  useListeners,
  usePanel,
  useSection,
  useSlots,
  useStore,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect
};
//# sourceMappingURL=kirbyuse.js.map
