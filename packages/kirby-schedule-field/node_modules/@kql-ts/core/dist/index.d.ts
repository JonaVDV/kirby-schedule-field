import { Component } from 'svelte';

interface Image {
    id: string;
    alt: string;
    url: string;
    uuid: `file://${string}`;
}

/**
 * @fileoverview Block types
 * these types were inspired (and mostly copied from) [these types](https://github.com/johannschopplich/kirby-types/blob/main/src/blocks.d.ts) from Johann Schopplich
 *
 * this file defines the block types from kirby with their content properties. these can be used in order to make components.
 */

/**
 * Default block types with their content properties
 *
 */
interface KirbyDefaultBlocks extends Blocks.KirbyDefaultBlocks {
    code: {
        code: string;
        language: string;
    };
    gallery: {
        images: string[];
    };
    heading: {
        level: string;
        text: string;
    };
    text: {
        text: string;
    };
    quote: {
        text: string;
        citation: string;
    };
    list: {
        text: string;
    };
    markdown: {
        text: string;
    };
    image: {
        alt: string;
        caption: string;
        crop: boolean;
        image: `file://${string}`[];
        link: string;
        location: string;
        ratio: string;
        src: string;
    };
    video: {
        url: string;
        caption: string;
    };
}
/**
 * Base block type
 *
 * @param TType - Type of the block
 */
interface KirbyBlock<TType extends KirbyBlockType> {
    id: string;
    type: TType;
    isHidden: boolean;
    content: KirbyDefaultBlocks[TType];
}
type Prettify<T> = {
    [P in keyof T]: T[P];
};
type KirbyBlockType = Prettify<keyof KirbyDefaultBlocks>;
type BlocksMap = Partial<{
    [TType in KirbyBlockType]: Component<KirbyComponentProps<TType>>;
}>;
type KirbyComponentProps<TBlockType extends KirbyBlockType> = {
    block?: KirbyBlock<TBlockType>;
};

type Content = {
    __default: KirbyBlock<KirbyBlockType>;
    __extra: Field;
    data: Record<string, Field>;
    fields: () => {
        [key: string]: Field;
    }[];
    /**Checks if a content field is set*/
    has: (key: string) => boolean;
    /**Returns all field keys*/
    keys: () => string[];
    /**Returns a clone of the content object without the fields, specified by the passed key(s) */
    not: (...keys: string[]) => Content;
};

interface Page extends KQL.Page, allowedMethodsForChildren, allowedMethodsForFiles, allowedMethodsForModels, AllowedMethodsForSiblings, AllowedMethodsForParents {
    __extra: Field;
    __default: {
        children: string[];
        content: {
            [key: string]: string;
        };
        drafts: string[];
        files: any[];
        id: string;
        intendedTemplate: string;
        isHomePage: boolean;
        isErrorPage: boolean;
        num: number;
        template: string;
        title: string;
        slug: string;
        status: string;
        uid: string;
        url: string;
    };
    depth: () => number;
    exists: () => boolean;
    hasTemplate: () => boolean;
    id: () => string;
    isDraft: () => boolean;
    isErrorPage: () => boolean;
    isHomePage: () => boolean;
    isHomeOrErrorPage: () => boolean;
    isListed: () => boolean;
    isReadable: () => boolean;
    isSortable: () => boolean;
    isUnlisted: () => boolean;
    mediaUrl: () => string;
    modified: (format: string, handler: string, languageCode: string) => string | number | false | null;
    num: () => number;
    panel: () => Page;
    parent: () => Page;
    parentId: () => string;
    parentModel: () => Page | Site;
    permalink: () => string;
    permissions: () => any;
    previewUrl: () => string;
    slug: (languageCode: string) => string;
    status: () => string;
    title: Field;
    uid: () => string;
    uri: (languageCode: string) => string;
    content: (languageCode?: string) => Content & {
        [key: string]: Field;
    };
    site: () => Site;
    children: () => Pages;
    childrenAndDrafts: () => Pages;
    findPageOrDraft: (path: string) => Page;
    grandChildren: () => Pages;
    hasChildren: () => boolean;
    hasDrafts: () => boolean;
    hasListedChildren: () => boolean;
    hasUnlistedChildren: () => boolean;
    indexOf: (collection: Array<any>) => number | false;
    next: (collection: Array<any>) => Array<any>;
    nextAll: (collection: Array<any>) => Array<any>;
    prev: (collection: Array<any>) => Array<any>;
    prevAll: (collection: Array<any>) => Array<any>;
    siblings: (self: boolean) => Array<any>;
    hasNext: (collection: Array<any>) => boolean;
    isFirst: (collection: Array<any>) => boolean;
}
interface Pages extends Collection<Page> {
    listed: () => Pages;
}

interface Collection<TObject> {
    __collection: TObject;
    findBy: (attribute: string, value: any) => Array<any>;
    has: (key: string) => boolean;
    not: (keys: string[]) => Collection<TObject>;
    pagination: () => Array<any>;
    chunk: (size: number) => Array<any>;
    filterBy: (args: Array<any>) => Array<any>;
    find: (keys: Array<string>) => Array<any>;
    findByKey: (key: string) => Array<any>;
    first: () => TObject;
    flip: () => Collection<TObject>;
    groupBy: (args: Array<any>) => Array<any>;
    isEmpty: () => boolean;
    isEven: () => boolean;
    isNotEmpty: () => boolean;
    isOdd: () => boolean;
    last: () => Array<any>;
    limit: (limit: number) => Array<any>;
    nth: (n: number) => Array<any>;
    offset: (offset: number) => Array<any>;
    shuffle: () => Array<any>;
    slice: (offset: number, limit: number) => Array<any>;
    sortBy: (...args: Array<string>) => Pages;
    without: (keys: Array<any>) => Array<any>;
    keys: () => string[];
    prev: () => TObject | null;
    next: () => TObject | null;
    count: () => number;
}

type CropPositions = "top left" | "top" | "top right" | "left" | "center" | "right" | "bottom left" | "bottom" | "bottom right";
interface File extends KQL.File, allowedMethodsForModels, AllowedMethodsForParents, AllowedMethodsForSiblings {
    __extra: Field;
    __default: {
        extension: string;
        filename: string;
        height: number;
        id: string;
        mime: string;
        niceSize: string;
        template: string;
        type: string;
        url: string;
        width: number;
    };
    blur: (pixels: number | boolean) => File;
    bw: () => File;
    crop: (width: number, height: number, options?: CropPositions | string) => File;
    extension: () => string;
    filename: () => string;
    files: () => Files;
    id: () => string;
    mediaUrl: () => string;
    parentId: () => string;
    permalink: () => string;
    template: () => string;
    templateSiblings: (self: boolean) => Files;
    url: () => string;
    height: () => number;
    previewUrl: () => string;
    grayscale: () => File;
    greyscale: () => File;
    resize: (width?: number, height?: number, quality?: number) => File;
    srcset: (sizes: Array<string> | string | null) => string;
    thumb: (options?: Array<any> | string | null) => File;
    indexOf: (collection: Array<any>) => number | false;
    next: (collection: Array<any>) => Array<any>;
    nextAll: (collection: Array<any>) => Array<any>;
    prev: (collection: Array<any>) => Array<any>;
    prevAll: (collection: Array<any>) => Array<any>;
    exists: () => boolean;
    type: () => string;
}
interface Files extends Collection<File> {
}

interface allowedMethodsForChildren {
    /**Returns all published children*/
    children: () => Pages;
    /**
     * Returns all published and draft children at the same time
     */
    childrenAndDrafts: () => Pages;
    /**
     * Searches for a draft child by ID
     * @param path the id of the child
     * @returns the found page or null if not found
     */
    draft: (path: string) => Page | null;
    /**
     * Returns all draft children
     * @returns the draft children
     */
    drafts: () => Pages;
    /**
     * Finds one or multiple published children by their id
     * @param args
     * @returns the found page or pages or null if not found
     */
    find: (...args: string[]) => Page | Pages | null;
    /**
     * Finds a single published or draft child
     * @param path the path of the child
     */
    findPageOrDraft: (path: string) => Page | null;
    /**
     * Returns a collection of all published children of published children
     */
    grandChildren: () => Pages;
    /**
     * Checks if the model has any published children
     */
    hasChildren: () => boolean;
    /**
     * Checks if the model has any draft children
     */
    hasDrafts: () => boolean;
    /**
     * Checks if the model has any listed children
     */
    hasListedChildren: () => boolean;
    /**
     * Checks if the model has any unlisted children
     */
    hasUnlistedChildren: () => boolean;
    /**
     * Creates a flat child index
     * @param drafts if set to true, draft children are included
     * @returns the child index
     */
    index: (drafts?: boolean) => Pages;
    /**
     * Search all pages within the current page
     * @param query the search query
     * @returns the search result
     */
    search: (query?: string) => Pages;
}
interface allowedMethodsForFiles {
    /** Filters the Files collection by type audio*/
    audio: () => Files;
    /**Filters the Files collection by type code*/
    code: () => Files;
    /**
     * Filters the Files collection by type document
     */
    documents: () => Files;
    /**Returns a specific file by filename or the first one*/
    file: (filename?: string) => File;
    /**Returns the Files collection */
    files: () => Files;
    hasAudio: () => boolean;
    /**Checks if the Files collection has any code files*/
    hasCode: () => boolean;
    /**Checks if the Files collection has any document files*/
    hasDocuments: () => boolean;
    /**Checks if the Files collection has any files*/
    hasFiles: () => boolean;
    /**Checks if the Files collection has any images*/
    hasImages: () => boolean;
    /**Checks if the Files collection has any video */
    hasVideos: () => boolean;
    /**
     * Returns a specific image by filename or the first one
     * @param filename the filename of the image
     * @returns the image or null if not found
     */
    image: (filename?: string) => File | null;
    /**
     * Filters the Files collection by type image
     * @returns the filtered collection
     */
    images: () => Files;
    /**
     * Filters the Files collection by type video
     * @returns the filtered collection
     */
    videos: () => Files;
}
interface allowedMethodsForModels {
    apiUrl: () => string;
    blueprint: () => any;
    /**Returns the content */
    content: () => Content;
    dragText: any;
    exists: any;
    id: () => string;
    mediaUrl: any;
    modified: any;
    permissions: any;
    panel: any;
    /**
     * Return the permanent URL to the page using its UUID
     */
    permalink: () => string | null;
    /**
     * Simplified File URL that uses the parent Page URL and the filename as a more stable alternative for the media URLs.
     */
    previewUrl: () => string | null;
    /**
     * Returns the Url
     */
    url: () => string;
}
interface AllowedMethodsForSiblings {
    indexOf: any;
    next: any;
    nextAll: any;
    prev: any;
    prevAll: any;
    siblings: any;
    hasNext: any;
    /**
     * Checks if there's a previous item in the collection
     */
    hasPrev: () => boolean;
    isFirst: any;
    /**
     * Checks if the item is the last in the collection
     */
    isLast: () => boolean;
    /**
     * Checks if the item is at a certain position
     * @param n
     * @returns
     */
    isNth: (n: number) => boolean;
}
interface AllowedMethodsForParents {
    parent: any;
    parentId: any;
    parentModel: any;
    site: () => Site;
}

interface Block extends AllowedMethodsForSiblings {
    __default: {
        content: () => Content;
        id: () => string;
        isEmpty: () => boolean;
        isHidden: () => boolean;
        type: () => KirbyBlockType;
    };
    content: () => Content;
    id: () => string;
    isEmpty: () => boolean;
    isHidden: () => boolean;
    isNotEmpty: () => boolean;
    toField: () => Field;
    toHtml: () => string;
    parent: () => Content;
    type: () => KirbyBlockType;
}
interface Blocks$1 extends Collection<Block> {
    /**Creates an excerpt of the field value without html or any other formatting. */
    excerpt: (chars: number, strip?: boolean, rep?: string) => Field;
    toHtml: () => string;
}

interface Layout extends AllowedMethodsForSiblings {
    __default: {
        attrs: () => Content;
        columns: () => LayoutColumns;
        id: () => string;
    };
    __extra: Field;
    attrs: () => Content;
    columns: () => LayoutColumns;
    id: () => string;
    isEmpty: () => boolean;
    isNotEmpty: () => boolean;
    parent: () => Content;
}
interface Layouts extends Collection<Layout> {
}
interface LayoutColumn extends AllowedMethodsForSiblings {
    __default: {
        blocks: () => Blocks$1;
        id: () => string;
        width: () => string;
    };
    blocks: () => Blocks$1;
    id: () => string;
    isEmpty: () => boolean;
    isNotEmpty: () => boolean;
    span: () => number;
    width: () => string;
}
interface LayoutColumns extends Collection<LayoutColumn> {
}

interface StructureObject<TStructureOutput> extends AllowedMethodsForSiblings {
    __extra: Field;
    /**Returns the unique item id (UUID v4)*/
    id: () => string;
    /**Returns the content*/
    content: () => Content;
    __default: TStructureOutput;
}

type EscapeContext = "html" | "attr" | "js" | "css" | "url" | "xml";
type Validators = "accepted" | "alpha" | "alphanum" | "between" | "callback" | "contains" | "date" | "denied" | "different" | "email" | "empty" | "endsWith" | "filename" | "in" | "integer" | "ip" | "json" | "less" | "match" | "max" | "maxLength" | "maxWords" | "min" | "minLength" | "minWords" | "more" | "notContains" | "notEmpty" | "notIn" | "num" | "required" | "same" | "size" | "startsWith" | "tel" | "time" | "url" | "uuid";
interface Field<TStructureOutput extends Record<string, unknown> = Record<string, unknown>> extends KQL.Field {
    __default: string;
    /**Escapes the field value to be safely used in HTML templates without the risk of XSS attacks @param context - The context to escape the field value for @alias `esc`*/
    escape: (context: EscapeContext) => Field;
    /**alias for escape */
    esc: (context: EscapeContext) => Field;
    /**Creates an excerpt of the field value without html or any other formatting. */
    excerpt: (chars: number, strip: boolean, rep: string) => Field;
    /**Checks if the field exists in the content data array */
    exists: () => boolean;
    /**Converts the field content to a valid HTML*/
    html: () => Field;
    /**
     * Strips all block-level HTML elements from the field value,
     * it can be safely placed inside of other inline elements without the risk of breaking the HTML structure.
     */
    inline: () => Field;
    /**Checks if the field content is empty */
    isEmpty: () => boolean;
    /** Converts the field content from inline Markdown/Kirbytext to valid HTML
     * @alias kti
     */
    /**Converts the field value into a proper boolean and inverts it*/
    isFalse: () => boolean;
    /**Checks if the field content is not empty */
    isNotEmpty: () => boolean;
    /**Converts the field value into a proper boolean */
    isTrue: () => boolean;
    /**Validates the field content with the given validator and parameters */
    isValid: (validator: Validators, ...args: any[]) => boolean;
    /**alias for isValid */
    v: (validator: Validators, ...args: any[]) => boolean;
    /**Returns the name of the field */
    key: () => string;
    /**Parses all KirbyTags without also parsing Markdown*/
    kirbytags: () => Field;
    /**Converts the field content from Markdown/Kirbytext to valid HTML */
    kirbytext: () => Field;
    /**alias for kirbyText */
    kt: () => Field;
    /**Converts the field content from inline Markdown/Kirbytext to valid HTML */
    kirbytextinline: () => Field;
    /** alias for kirbytextinline */
    kti: () => Field;
    /**Returns the length of the field content*/
    length: () => number;
    /** Converts the field content to lowercase */
    lower: () => Lowercase<string>;
    /**Converts markdown to valid HTML*/
    markdown: () => Field;
    /**alias for markdown() */
    md: () => Field;
    /**@todo need a type here */
    model: () => any;
    /**Converts all line breaks in the field content to `<br>` tags. */
    nl2br: () => Field;
    /**Provides a fallback if the field value is empty */
    or: (fallback: any) => Field;
    /**It parses any queries found in the field value.*/
    replace: () => Field;
    /**Cuts the string after the given length and adds "…" if it is longer
     * @param length - The number of characters in the string
     * @param appendix - An optional replacement for the missing rest
     */
    short: (length: number, appendix: string) => Field;
    /**Converts the field content to a slug*/
    slug: () => Field;
    /**
     * Converts the field content to title case
     * @see https://getkirby.com/docs/reference/system/options/smartypants
     */
    smartypants: () => Field;
    /**Splits the field content into an array */
    split: (separator: string) => Array<string>;
    /** Converts the Field object to an array
     * @todo maybe a type for this?
     */
    toArray: () => any[];
    /** Converts a yaml or json field to a Blocks object*/
    toBlocks: () => Blocks$1;
    /** Converts the field value into a proper boolean
     * @todo find a proper replacement name for the parameter
     */
    toBool: ($default: boolean) => boolean;
    /**Parses the field value with the given method
     * ## available methods are:
     * - ',' - Comma separated values
     * - 'yaml' - YAML formatted values
     * - 'json' - JSON formatted values
     * @param method - The method to parse the field value with
     * @returns The parsed field value
     */
    toData: (method: "," | "yaml" | "json") => Field;
    /**Converts the field value to a timestamp or a formatted date*/
    toDate: (format?: string, fallback?: string) => string | number | null;
    /**Returns a file object from a filename in the field*/
    toFile: () => File;
    /**Returns a file collection from a yaml list of filenames in the field */
    toFiles: (separator: string) => File[];
    /**Converts the field value into a proper float */
    toFloat: ($default: 0.0 | number) => number;
    /**Converts the field value into a proper integer */
    toInt: ($default: 0 | number) => number;
    /**Parse layouts and turn them into Layout objects */
    toLayouts: () => Layouts;
    /**Wraps a link tag around the field value. The field value is used as the link text
     * @param attr1 - Can be an optional Url. If no Url is set, the Url of the Page, File or Site will be used. Can also be an array of link attributes
     * @param attr2 - If `$attr1 `is used to set the Url, you can use `$attr2` to pass an array of additional attributes.
     */
    toLink: (attr1?: string | string[], attr2?: string[]) => Field;
    /**Parse yaml data and convert it to a content object*/
    toObject: () => Content;
    /**Returns a page object from a page id in the field */
    toPage: () => Page | null;
    /**Returns a pages collection from a yaml list of page ids in the field */
    toPages: () => Pages;
    /** Turns the field value into an QR code object*/
    toQrCode: () => QrCode;
    /**
     * Returns the field value as string
     */
    toString: () => string;
    /**Converts a yaml field to a Structure object*/
    toStructure: () => Collection<StructureObject<TStructureOutput>>;
    /**Converts the field value to a Unix timestamp*/
    toTimestamp: () => number | false;
    /**Turns the field value into an absolute Url*/
    toUrl: () => string | null;
    /**Converts a user email address to a user object*/
    toUser: () => User | null;
    /**Returns a users collection from a yaml list of user email addresses in the field */
    toUsers: (separator?: string) => User[];
    /**
     * Converts the field content to uppercase
     */
    upper: () => Uppercase<string>;
    /**Returns the field content. If a new value is passed, the modified field will be returned. Otherwise it will return the field value. */
    value: (value?: string) => Field;
    /**
     * Avoids typographical widows in strings by replacing the last space with `&nbsp;`
     */
    widont: () => Field;
    /** Returns the number of words in the text*/
    words: () => number;
    /**Converts the field content to valid XML */
    xml: () => Field;
    yaml: () => Field[];
}
/**@todo make a proper interface for the following interfaces */
interface User {
}
interface QrCode {
}

interface Site extends KQL.Site, allowedMethodsForChildren, allowedMethodsForFiles, allowedMethodsForModels {
    __extra: Field;
    __default: {
        title: string;
        children: string[];
        url: string;
    };
    breadcrumb: () => Pages;
    errorPage: () => Page;
    errorPageId: () => string;
    exists: () => boolean;
    homePage: () => Page;
    homePageId: () => string;
    mediaUrl: () => string;
    modified: (format: string, handler: string) => string | number;
    page: (path: string) => Page;
    pages: () => Pages;
    panel: () => Site;
    children: () => Pages;
    previewUrl: () => string;
    title: () => Field;
}

interface App extends KQL.App {
}

/**
 * @fileoverview Provides proxy-based query builders for the Kirby Query Language (KQL)
 * This module enables type-safe querying of Kirby CMS objects using JavaScript functions
 * instead of raw strings.
 */

/**
 * Adds dynamic property access to a type that may have extra properties
 * @template T The base type that may contain an __extra property
 * @property `{T['__extra'] | any}` `[key: string]` Dynamic property accessor
 */
type WithDynamicProps<T extends {
    __extra?: unknown;
}> = T & {
    [key: string]: T extends {
        __extra: unknown;
    } ? T["__extra"] : unknown;
};
/**
 * Creates a query builder for the Kirby site object
 * @returns {WithDynamicProps<Site>} A proxy object for querying site properties
 * @example
 * site().title.toString() // Returns "site.title"
 */
declare const site: () => WithDynamicProps<Site>;
/**
 * Creates a query builder for Kirby page objects
 * @param {string} [page] Optional page identifier
 * @returns {WithDynamicProps<Page>} A proxy object for querying page properties
 * @example
 * page().title.toString() // Returns "page.title"
 */
declare const page: (page?: string) => WithDynamicProps<Page>;
/**
 * Creates a query builder for the Kirby application object
 * @returns {WithDynamicProps<App>} A proxy object for querying Kirby app properties
 * @example
 * kirby().version().toString() // Returns "kirby.version()"
 */
declare const kirby: () => WithDynamicProps<App>;
/**
 * Creates a query builder for Kirby file objects
 * @returns {WithDynamicProps<File>} A proxy object for querying file properties
 * @example
 * file().filename.toString() // Returns "file.filename"
 */
declare const file: () => WithDynamicProps<File>;

/**
 * Transform the query by converting 'query' keys to their string paths, and recursively processing nested objects and functions
 * @param query - The query object to transform
 * @returns The transformed query object
 */
declare function transformQuery<T extends object>(query: T): Record<string, unknown>;

type ExtractBaseType<T> = T extends (...args: any[]) => infer R ? ExtractBaseType<R> : T extends {
    __default: any;
} ? T["__default"] : T;
type IsCollection<T> = T extends Collection<any> ? true : T extends (...args: any[]) => Collection<any> ? true : false;
type CollectionItemType<T> = T extends Collection<infer U> ? U : T extends (...args: any[]) => Collection<infer U> ? U : T;
/**
 * WrapIfCollection takes a type and a query and returns the type as an array if the query is a collection
 */
type WrapIfCollection<TObject, Query> = IsCollection<Query> extends true ? Array<TObject extends Array<any> ? TObject[0] : TObject> : TObject;
/**
 * Get the key from the query or if it is not there, return the type of the __extra property
 */
type GetKeyFromQueryOrExtra<T extends {
    __extra: any;
}, K> = K extends keyof T ? T[K] : T["__extra"];
/**
 * used to check if a value of a key is a boolean if it is, we return true, otherwise false
 */
type IsKeyBooleanType<TObject extends Record<string, any>, Key> = Key extends keyof TObject ? TObject[Key] extends boolean ? true : false : false;
/**
 *
 * Get the __default property from a query object if it exists, otherwise get the __extra property
 */
type GetQueryTypeDefaultOrExtra<TQuery> = TQuery extends {
    __default: infer Default;
} ? Default : TQuery extends {
    __extra: infer Extra;
} ? Extra : never;
/**
 * gets the __default property from an object if it exists, otherwise it returns the object itself
 */
type ExtractDefault<T> = T extends {
    __default: infer D;
} ? D : T;
type FunctionToReturn<T> = T extends (...args: any) => any ? ReturnType<T> : T;
/**
 * CompareAndGetFromQuery takes a select object, a key, and a query object,
 * and returns the appropriate type based on the key's value in the select object.
 */
type CompareAndGetFromQuery<TSelectObject extends Record<string, any>, Key, Query extends {
    __extra: any;
}> = Key extends keyof TSelectObject ? IsKeyBooleanType<TSelectObject, Key> extends true ? ExtractBaseType<GetKeyFromQueryOrExtra<CollectionItemType<Query>, Key>> : TSelectObject[Key] extends KQLQuery ? WrapIfCollection<KQLQueryTypeResolver<{
    query: CollectionItemType<TSelectObject[Key]["query"]>;
    select: TSelectObject[Key]["select"];
}>, TSelectObject[Key]["query"]> : IsCollection<TSelectObject[Key]> extends true ? KQLQueryTypeResolver<HandleDeepCollections<TSelectObject[Key]>> : ExtractBaseType<TSelectObject[Key]> : GetQueryTypeDefaultOrExtra<Query>;
type KQLQueryTypeResolver<T extends KQLQuery> = T extends {
    select: infer S;
} ? WrapIfCollection<{
    [K in keyof T["select"]]: CompareAndGetFromQuery<T["select"], K, T["query"]>;
}, T["query"]> : T extends {
    query: infer Q;
} ? IsCollection<Q> extends true ? Array<ExtractBaseType<CollectionItemType<Q>>> : ExtractBaseType<Q> : never;
type KQLQuery = {
    query: any;
    select?: any;
    models?: any;
    pagination?: {
        limit?: number;
        page?: number;
    };
};
type HandleDeepCollections<T> = T extends Collection<infer U> ? {
    query: Collection<U>;
    select: {
        [K in keyof ExtractDefault<U>]: HandleDeepCollections<IsCollection<FunctionToReturn<ExtractDefault<U>[K]>> extends true ? FunctionToReturn<ExtractDefault<U>[K]> : true>;
    };
} : T;

interface KirbyLayout {
    id: string;
    columns: KirbyColumn[];
    attrs: any;
}
interface KirbyColumn {
    id: string;
    width: string;
    blocks: KirbyBlock<any>[];
}

export { type BlocksMap, type Field, type Image, type KQLQuery, type KQLQueryTypeResolver, type KirbyBlock, type KirbyBlockType, type KirbyColumn, type KirbyComponentProps, type KirbyDefaultBlocks, type KirbyLayout, file, kirby, page, site, transformQuery };
